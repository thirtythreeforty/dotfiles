#!/bin/sh

# Rust has a very irritating policy of completely disabling unstable features
# when using a "stable" release (they aren't even available behind a flag).  I
# completely understand the rationale behind this.  Normally such a strategy
# would be fine, except it is not currently possible to build the Rust library
# using a stable Rust compiler.  Rust itself manages to build its own standard
# library by using a "bootstrap key," which is an environment variable known
# only at build time that the compiler checks for.  If it is present, the
# compiler allows all the unstable behavior.

# Of course, the key will be embedded in the rustc binaries, because it has to
# check for it at runtime.  By default it is merely a timestamp, in the
# HH:MM:SS format.  We can "unlock" a stable copy of Rust by extracting this
# value and sticking it back in the environment, essentially fooling the
# compiler into thinking it is running in its build system.  I hope they do not
# change this to something even more annoying to circumvent in the future.

# Please do not use this to circumvent the release channel strategy the Rust
# folks are using.  I use it only because I need to be able to build the
# standard library with a stable copy of Rust.

# -- A Determined User


# Find the name of the librustc library
LIBRUST=$(ls /usr/lib/librustc-*.so)
if [ -z $LIBRUST ]; then
	echo "Can't find librustc-*.so!"
	return
fi

# Pull strings from the file, and grep and sed to filter out the key.
TIMEREGEX='[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]]:[[:digit:]][[:digit:]]'
KEY=$(strings $LIBRUST | grep -e $TIMEREGEX | head -n1 | sed "s/.*\($TIMEREGEX\).*/\1/")

if [ -n $KEY ]; then
	# We found it!  Well, probably.
	echo "The key is: RUSTC_BOOTSTRAP_KEY='"$KEY"'"

	# Export it.  Note that the user must source this script for this to have
	# any effect.
	export RUSTC_BOOTSTRAP_KEY=$KEY
else
	echo "Could not find bootstrap key matching HH:MM:SS pattern!"
fi
